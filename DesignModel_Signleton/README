基础要点：
全局只有一个实例：static特性，同时禁止用户自己生命并定义实例（把构造函数设为private）
保证线程安全
禁止赋值和拷贝
用户通过接口获取实例：使用static类成员函数

类中的static变量会保证全局唯一，多个实例共享一个static变量，如果该static变量已经初始化过了，不会再次初始化
被static修饰的成员变量和成员方法独立于该类的任何对象，也就是说，它不依赖与类的特定的实例，被类的所有实例共享
静态变量在内存中只有一个拷贝

通过静态的类方法（getInstance）获取instance，该方法是静态方法，instance由该方法返回（被方法使用），如果instance非静态，无法被getInstance调用
instance需要调用gerInstance的时候被初始化，只有static的成员才能在没有创建对象时进行初始化，且类的静态成员在类第一次被使用时初始化后就不再被初始化，保证了单例
static类型的instance存在静态存储区，媒体调用时，都指向的同一个对象


static修饰属性
static修饰的属性为类属性（静态变量），不属于对象的属性，所以在类的实例创建时，静态变量不会存在在堆空间中;
调用方式：
静态属性在该类被调用的时候进入数据共享区，静态属性自身被调用时进入栈空间，执行完出栈
对象属性在对象创建时产生（堆空间），在该对象编程匿名对象时（对象所在的方法执行完毕，对象出栈）


程序内存结构：
a   最低内存地址
b   代码区(code area)  :函数代码块的二进制代码
c   数据区(data area)  
c.0 文字常量区         :常量字符串存储区
c.1 未初始化静态变量区 :没有初始化的全局变量和静态变量
c.2 已初始化静态变量区 :初始化的全局变量和静态变量
d   堆区(heap area)    :动态分配的数据
e   栈区(stack area)   :局部变量存放区
f   命令行参数区       :命令行参数和环境变量
g   最高内存地址

程序中的二进制代码是存放在静态存储区域。C/C++中的全局变量和静态变量都是存储在数据区中，且不论static变量的作用域如何，变量的内存位置都在数据区中（而非函数栈上），这就解释了为何函数中的局部静态变量在函数退出后依然存在，并不会随着函数退出消亡（析构）

static修饰符
static的主要作用是限定变量或函数为静态存储，如果用static限定全局变量和函数，则可以将该对象的作用域限定为被编译源文件的剩余部分。通过static限定全局变量，可以达到隐藏外部对象的目的。因而，static限定的变量或函数不会和同一程序中的其他文件中同名的相互冲突。如果用static限定函数局部变量，则该变量从程序一开始就拥有内存，不会随着所在函数的调用和退出而分配和消失。在类中，静态成员可以实现对各对象之间的数据共享，并且使用静态数据还不会破坏隐藏的原则，保证了安全性：

静态变量或静态函数的好处：
1 对于类成员static变量，可以节省内存，所用对象共享该数据
2 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多
3 关键字“static"，中文”静态的“, 所以内部函数又称静态函数，但此处"static"的含义不是指存储方式，而是指对函数的作用域仅限于本文件。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其他文件中的函数同名，因为同名也没有关系

参考资料：

https://www.cnblogs.com/sunchaothu/p/10389842.html


https://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html

https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function




结论： 
1.static成员函数不包含this指针 
2.static成员函数不能为virtual 
3.不能存在static和non-static成员函数有相同的名字和参数 
4.static 成员函数不能被声明成const、volatile或者const volatile。

原因： 
const成员函数用来修饰该成员函数的隐式this指针为const型，而static成员函数不包含this指针。

原文链接：https://blog.csdn.net/zhangxiao93/article/details/74502504